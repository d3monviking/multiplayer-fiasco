// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_GAME_H_
#define FLATBUFFERS_GENERATED_MESSAGE_GAME_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace Game {

struct Vec2;

struct ClientMessage;
struct ClientMessageBuilder;

struct ServerMessage;
struct ServerMessageBuilder;

struct PlayerData;
struct PlayerDataBuilder;

struct GameMessage;
struct GameMessageBuilder;

enum GameData : uint8_t {
  GameData_NONE = 0,
  GameData_ServerMessage = 1,
  GameData_ClientMessage = 2,
  GameData_MIN = GameData_NONE,
  GameData_MAX = GameData_ClientMessage
};

inline const GameData (&EnumValuesGameData())[3] {
  static const GameData values[] = {
    GameData_NONE,
    GameData_ServerMessage,
    GameData_ClientMessage
  };
  return values;
}

inline const char * const *EnumNamesGameData() {
  static const char * const names[4] = {
    "NONE",
    "ServerMessage",
    "ClientMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameData(GameData e) {
  if (::flatbuffers::IsOutRange(e, GameData_NONE, GameData_ClientMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameData()[index];
}

template<typename T> struct GameDataTraits {
  static const GameData enum_value = GameData_NONE;
};

template<> struct GameDataTraits<Game::ServerMessage> {
  static const GameData enum_value = GameData_ServerMessage;
};

template<> struct GameDataTraits<Game::ClientMessage> {
  static const GameData enum_value = GameData_ClientMessage;
};

bool VerifyGameData(::flatbuffers::Verifier &verifier, const void *obj, GameData type);
bool VerifyGameDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

struct ClientMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SELF_DATA = 4,
    VT_PLAYER_INPUT = 6,
    VT_SEQUENCE_NUMBER = 8
  };
  const Game::PlayerData *self_data() const {
    return GetPointer<const Game::PlayerData *>(VT_SELF_DATA);
  }
  const ::flatbuffers::Vector<uint8_t> *player_input() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PLAYER_INPUT);
  }
  int32_t sequence_number() const {
    return GetField<int32_t>(VT_SEQUENCE_NUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SELF_DATA) &&
           verifier.VerifyTable(self_data()) &&
           VerifyOffset(verifier, VT_PLAYER_INPUT) &&
           verifier.VerifyVector(player_input()) &&
           VerifyField<int32_t>(verifier, VT_SEQUENCE_NUMBER, 4) &&
           verifier.EndTable();
  }
};

struct ClientMessageBuilder {
  typedef ClientMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_self_data(::flatbuffers::Offset<Game::PlayerData> self_data) {
    fbb_.AddOffset(ClientMessage::VT_SELF_DATA, self_data);
  }
  void add_player_input(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> player_input) {
    fbb_.AddOffset(ClientMessage::VT_PLAYER_INPUT, player_input);
  }
  void add_sequence_number(int32_t sequence_number) {
    fbb_.AddElement<int32_t>(ClientMessage::VT_SEQUENCE_NUMBER, sequence_number, 0);
  }
  explicit ClientMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientMessage> CreateClientMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Game::PlayerData> self_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> player_input = 0,
    int32_t sequence_number = 0) {
  ClientMessageBuilder builder_(_fbb);
  builder_.add_sequence_number(sequence_number);
  builder_.add_player_input(player_input);
  builder_.add_self_data(self_data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ClientMessage> CreateClientMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Game::PlayerData> self_data = 0,
    const std::vector<uint8_t> *player_input = nullptr,
    int32_t sequence_number = 0) {
  auto player_input__ = player_input ? _fbb.CreateVector<uint8_t>(*player_input) : 0;
  return Game::CreateClientMessage(
      _fbb,
      self_data,
      player_input__,
      sequence_number);
}

struct ServerMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServerMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_CODE = 4,
    VT_PLAYER_DATA = 6,
    VT_PLAYER_ID = 8
  };
  int32_t message_code() const {
    return GetField<int32_t>(VT_MESSAGE_CODE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Game::PlayerData>> *player_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Game::PlayerData>> *>(VT_PLAYER_DATA);
  }
  int32_t player_id() const {
    return GetField<int32_t>(VT_PLAYER_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGE_CODE, 4) &&
           VerifyOffset(verifier, VT_PLAYER_DATA) &&
           verifier.VerifyVector(player_data()) &&
           verifier.VerifyVectorOfTables(player_data()) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_ID, 4) &&
           verifier.EndTable();
  }
};

struct ServerMessageBuilder {
  typedef ServerMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_code(int32_t message_code) {
    fbb_.AddElement<int32_t>(ServerMessage::VT_MESSAGE_CODE, message_code, 0);
  }
  void add_player_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Game::PlayerData>>> player_data) {
    fbb_.AddOffset(ServerMessage::VT_PLAYER_DATA, player_data);
  }
  void add_player_id(int32_t player_id) {
    fbb_.AddElement<int32_t>(ServerMessage::VT_PLAYER_ID, player_id, 0);
  }
  explicit ServerMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServerMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServerMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ServerMessage> CreateServerMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t message_code = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Game::PlayerData>>> player_data = 0,
    int32_t player_id = 0) {
  ServerMessageBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_player_data(player_data);
  builder_.add_message_code(message_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ServerMessage> CreateServerMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t message_code = 0,
    const std::vector<::flatbuffers::Offset<Game::PlayerData>> *player_data = nullptr,
    int32_t player_id = 0) {
  auto player_data__ = player_data ? _fbb.CreateVector<::flatbuffers::Offset<Game::PlayerData>>(*player_data) : 0;
  return Game::CreateServerMessage(
      _fbb,
      message_code,
      player_data__,
      player_id);
}

struct PlayerData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_POS = 6,
    VT_VEL = 8,
    VT_TIMESTAMP = 10,
    VT_LAST_PROCESSED_SEQ_NUMBER = 12
  };
  int32_t player_id() const {
    return GetField<int32_t>(VT_PLAYER_ID, 0);
  }
  const Game::Vec2 *pos() const {
    return GetStruct<const Game::Vec2 *>(VT_POS);
  }
  const Game::Vec2 *vel() const {
    return GetStruct<const Game::Vec2 *>(VT_VEL);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int32_t last_processed_seq_number() const {
    return GetField<int32_t>(VT_LAST_PROCESSED_SEQ_NUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_ID, 4) &&
           VerifyField<Game::Vec2>(verifier, VT_POS, 4) &&
           VerifyField<Game::Vec2>(verifier, VT_VEL, 4) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<int32_t>(verifier, VT_LAST_PROCESSED_SEQ_NUMBER, 4) &&
           verifier.EndTable();
  }
};

struct PlayerDataBuilder {
  typedef PlayerData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(int32_t player_id) {
    fbb_.AddElement<int32_t>(PlayerData::VT_PLAYER_ID, player_id, 0);
  }
  void add_pos(const Game::Vec2 *pos) {
    fbb_.AddStruct(PlayerData::VT_POS, pos);
  }
  void add_vel(const Game::Vec2 *vel) {
    fbb_.AddStruct(PlayerData::VT_VEL, vel);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(PlayerData::VT_TIMESTAMP, timestamp, 0);
  }
  void add_last_processed_seq_number(int32_t last_processed_seq_number) {
    fbb_.AddElement<int32_t>(PlayerData::VT_LAST_PROCESSED_SEQ_NUMBER, last_processed_seq_number, 0);
  }
  explicit PlayerDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerData> CreatePlayerData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t player_id = 0,
    const Game::Vec2 *pos = nullptr,
    const Game::Vec2 *vel = nullptr,
    int64_t timestamp = 0,
    int32_t last_processed_seq_number = 0) {
  PlayerDataBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_last_processed_seq_number(last_processed_seq_number);
  builder_.add_vel(vel);
  builder_.add_pos(pos);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

struct GameMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE_TYPE = 4,
    VT_DATA_TYPE = 6
  };
  Game::GameData data_type_type() const {
    return static_cast<Game::GameData>(GetField<uint8_t>(VT_DATA_TYPE_TYPE, 0));
  }
  const void *data_type() const {
    return GetPointer<const void *>(VT_DATA_TYPE);
  }
  template<typename T> const T *data_type_as() const;
  const Game::ServerMessage *data_type_as_ServerMessage() const {
    return data_type_type() == Game::GameData_ServerMessage ? static_cast<const Game::ServerMessage *>(data_type()) : nullptr;
  }
  const Game::ClientMessage *data_type_as_ClientMessage() const {
    return data_type_type() == Game::GameData_ClientMessage ? static_cast<const Game::ClientMessage *>(data_type()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           VerifyGameData(verifier, data_type(), data_type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Game::ServerMessage *GameMessage::data_type_as<Game::ServerMessage>() const {
  return data_type_as_ServerMessage();
}

template<> inline const Game::ClientMessage *GameMessage::data_type_as<Game::ClientMessage>() const {
  return data_type_as_ClientMessage();
}

struct GameMessageBuilder {
  typedef GameMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data_type_type(Game::GameData data_type_type) {
    fbb_.AddElement<uint8_t>(GameMessage::VT_DATA_TYPE_TYPE, static_cast<uint8_t>(data_type_type), 0);
  }
  void add_data_type(::flatbuffers::Offset<void> data_type) {
    fbb_.AddOffset(GameMessage::VT_DATA_TYPE, data_type);
  }
  explicit GameMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameMessage> CreateGameMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Game::GameData data_type_type = Game::GameData_NONE,
    ::flatbuffers::Offset<void> data_type = 0) {
  GameMessageBuilder builder_(_fbb);
  builder_.add_data_type(data_type);
  builder_.add_data_type_type(data_type_type);
  return builder_.Finish();
}

inline bool VerifyGameData(::flatbuffers::Verifier &verifier, const void *obj, GameData type) {
  switch (type) {
    case GameData_NONE: {
      return true;
    }
    case GameData_ServerMessage: {
      auto ptr = reinterpret_cast<const Game::ServerMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameData_ClientMessage: {
      auto ptr = reinterpret_cast<const Game::ClientMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGameDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGameData(
        verifier,  values->Get(i), types->GetEnum<GameData>(i))) {
      return false;
    }
  }
  return true;
}

inline const Game::GameMessage *GetGameMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Game::GameMessage>(buf);
}

inline const Game::GameMessage *GetSizePrefixedGameMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Game::GameMessage>(buf);
}

inline bool VerifyGameMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Game::GameMessage>(nullptr);
}

inline bool VerifySizePrefixedGameMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Game::GameMessage>(nullptr);
}

inline void FinishGameMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Game::GameMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGameMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Game::GameMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Game

#endif  // FLATBUFFERS_GENERATED_MESSAGE_GAME_H_
